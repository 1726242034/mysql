union / union all: 可以拼接两个语句 查询的结果不会显示重复的数据(all会)
    select name,age from  user union select name,age from users

inner join内连接 / left join左连接 / right join右连接
    select id,name from stu inner join the on stu.id = the.stu_id
    内连接只会显示左右两个表有关系的数据
    左连接一定会显示左表所有的数据 但是不会管右表有没有与其对应的数据, 右表若没有与左表对应的数据 则显示null

on / where / group by
    on后面跟的是连接条件
    where后面跟的是筛选条件
    group by后面跟的是分组条件

在创建表时 int(5)的(5)是什么意思?
    搭配' zerofill '使用 表示显示宽度 不足部位以零填充, 不是代表能存放多少位数。
    比如' int(5) '表示显示宽度为5, 当存储一个'1'时 表中数据就是'00001'


数据库设计的三范式
    第一范式: 每一个表都应该有主键 并且每一个字段原子性不可再分

    第二范式: 建立在第一范式的基础上, 所有非主键字段完全依赖主键 不能产生部分依赖,
        部分依赖: 有多个主键时 非主键字段只依赖一个主键, 完全依赖: 有多个主键时 非主键字段完全依赖多个主键。
        多对多的时候, 三张表 关系表两个外键

    第三范式: 建立在第二范式的基础上, 所有非主键字段直接依赖主键 不能产生传递依赖
        传递依赖: 一个表中的a字段依赖b字段 b字段又依赖了c字段
        一对多的时候, 两张表 多的表加外键


    三范式可以解决数据的冗余, 但是多表查询时连接的表越多 执行速度越慢,
    所以有的时候要拿数据的冗余换取执行速度


    一对一: 比如有一张表有很多字段 但是常用的字段只有两个, 此时就可以把这两个字段组成一个表, 但是怎么让两个表关联?
        方案一: 主键共享 即让两张表产生关联的属性的主键一致
        方案二: 外键唯一 即让一张表的外键字段加上'unique' 让其绑定另一张表的主键



mysql优化
    内存中的数据 需要使用'地址'来进行读取 使用电流信号可以马上找到数据的地址, 所以读取速度很快 但是没电就不行了
    磁盘中的数据 需要让磁头转到数据存储的地方 才可以读取到, 所以读取速度比较慢

    磁盘预读特性
        硬盘分为读写磁头、磁道、扇区。一个盘片有正反两面 需要两个磁头, 盘片上一圈磁头工作路径为一个磁道 三个盘面重叠的磁道称为柱面,
        每个磁道上的一个弧段称为一个扇区。磁盘的容量为: 磁头数 × 磁道(柱面)数 × 盘片的扇区数 × 每个扇区的容量

        当需要从磁盘读取数据时, 系统会将逻辑地址发给磁盘, 磁盘的控制电路将逻辑地址转换为物理地址(哪个磁道, 哪个扇区)这时候就会有磁头的机械运动,
        磁头找到相应磁道(寻道), 时间称为寻道时间, 磁头找到对应磁道的对应扇区, 称为旋转时间。这是很大的时间消耗, 所以系统一般采取预读的方式, 减少磁盘I/O

        系统是分页读取和存储的 一般一页为4KB, 每次读取和存取的最小单元为一页, 预读即在读取的起始地址连续读取多个页面
        (现在不需要的页面也读取了 这样以后用时就不用再读取, 当一个页面用到时 大多数情况下 它周围的页面也会被用到)
        磁盘分页: 参考计算机操作系统的分页, 分段存储管理逻辑地址和物理地址被分为大小相同的页面, 逻辑地址中叫页, 物理地址中叫块

索引
    b+树的查找过程
        假设磁盘块1包含数据项17和35，包含指针P1、P2、P3。指针P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。
        真实的数据存在于叶子节点即3、5、  9、10、  13、15、  28、29、  36、60、  75、79、  90、99。
        (非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。)

        如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，
        此时发生一次IO。在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，
        发生第二次IO。29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，
        发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，
        如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。


    为什么要建立索引?
        因为数据库进行全表遍历速度会很慢, 索引可以建立一个B+树的结构 B+树的每一个节点都是索引列的值 由上而下的去查询 速度就很快了。
        为什么使用B+树而不用B树?
            B+树所有数据都存在叶子节点上 叶子节点之间相互都有指针指向下一个叶子, 所以全表遍历会很方便。
            数据放在普通的节点上 会增加普通节点的体积, 普通节点如果只放索引的字段可以放好多 但是放数据就放不了多少了。
            根据磁盘的预读性原理, 每一次内存都是从磁盘上读取一页的数据(4k), 这一页可以存放更多的索引列 而存放数据就存放的比较少
            所以每一次拿到的索引ID越多 B+树的层高就越低, 需要的磁盘IO次数就越少

    B-Tree、hash
        索引的实现方法分为两种 B-Tree、hash, 这两种索引方法都可以创建索引 且创建的索引类型也一样, 区别就是底层的算法不一致
        B-Tree： 创建基于B树结构的索引 具有范围查找和前缀查找的能力, 对于有N节点的B树 检索一条记录的复杂度为o(logN), 相当于二分查找
        hash: 创建基于hash表结构的索引 由于hash是散列算法无序 所以只能做等于查找, 不管多大的hash表 查找的复杂度都是o(1),
        如果值的差异性大, 并且以等值查找(=、<、>、in)为主 Hash索引是更高效的选择 它有o(1)的查找复杂度。
        如果值的差异性相对较差, 并組以范围查找为主 B树是更好的选择 它支持范围查找。

    优缺点
        优点:
            索引可以极大的加快查询的效率
            可以加速表和表之间的连接, 特别是在实现数据的参考完整性方面特别有意义
            在使用分组和排序子句进行数据检索时, 同样可以显著减少查询中分组和排序的时间

        缺点:
            索引是占用空间的
            当对表中的数据进行update insert delete的时候, 索引也要动态的维护, 这样就降低了数据的维护速度。

    注意事项
        索引要创建在where和join用到的字段上
        以下操作符号可以应用索引：<，<=，=，>，>=，BETWEEN，IN，LIKE不以%_开头
        以下需要注意不使用索引: <>, NOT IN, LIKE %_开头, <>可以用a>1 or a<3代替, NOT IN可以用NOT exists代替
        在使用max() min()时最好加上索引
        单索引要创建在确实需要的地方, 多列索引 有最佳左前缀特性 所以尽量左边的字段是最常用的
        索引不会包括有NULL值, 就是有NULL, 索引就失效(因为B+树的叶子节点需要节点中索引字段来排序, 非要传null就可以用其他数据代替null)
        使用短索引, 一个字段字太多, 可以建立部分索引, 只取前十个字节约空间
        不要在列上运算 例如:where MD5("password") = "myz"

    索引失效
        索引包括有NULL值
        复合索引不满足最左原则就不能使用索引
        如果条件中有or 那么所有索引都会失效！如果想让or和索引都生效 需要给or条件中的每个列都加上索引
        like查询以'%'开头的 索引会失效！例如 a like '%aaa'
        mysql估计使用全表扫描比使用索引快 就不使用索引
        参与了列计算的列 索引会失效, 因为参与了计算 索引的值就变得不可定了, 不可定的索引无法作为叶子节点数据排序的依据

    排序的索引问题
        mysql查询只使用一个索引, 因此如果where子句中已经使用了索引的话, 那么order by中的列是不会使用索引的。
        因此数据库默认排序可以符合要求的情况下不要使用排序操作; 尽量不要包含多个列的排序, 如果需要最好给这些列创建复合索引。

    覆盖索引
        根据id去聚簇索引中查找真正的数据，这个过程叫做回表, 如果你要的数据索引都有了不需要回表，就叫索引覆盖。


    什么样的字段适合创建索引?
        频繁作为where语句查询的字段
        关联字段需要创建索引 例如外键字段
        排序字段可以建立索引
        分组字段可以建立索引 因为分组的前提就是排序
        统计字段可以建立索引 例如count() max()

    什么样的字段不适合创建索引?
        频繁更新的字段不适合建立索引
        where条件中用不到的字段不适合创建索引
        表数据可以确定比较少的不需要创建索引
        对表的修改性能大于检索性能时 不应该创建索引 因为索引对检索比较差
        数据重复度较高且发布比较均匀的字段不适合创建索引(唯一性太差的字段) 例如性别 真假值
        参与列计算的列不适合加索引 索引会失效

        对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，
        在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。
        增加索引，并不能明显加快检索速度。

        对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为, 这些列的数据量要么相当大, 要么取值很少。

-------------------------------------------------------------------------------------------------------------------------------------------------------

    聚簇索引
        聚簇索引具有唯一性，由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引。
        表中行的物理顺序和索引中行的物理顺序是相同的，在创建任何非聚簇索引之前创建聚簇索引，
        这是因为聚簇索引改变了表中行的物理顺序，数据行按照一定的顺序排列，并且自动维护这个顺序

        聚簇索引查找数据
            InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，
            则按照B+树的检索算法即可查找到对应的叶子节点，之后获得行数据。
            聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一且非空的索引代替。如果没有这样的索引，
            InnoDB 会隐式定义一个主键（类似oracle中的RowId）来作为聚簇索引。如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，
            必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可

        非聚簇索引查找数据
            若对Name列进行条件搜索，则需要两个步骤：第一步在'次索引B+树'中检索Name，到达其叶子节点获取对应的主键(次索引的B+树叶子节点存放的是主键的位置)。
            第二步进行'回表'操作, 使用'次索引B+树'中检索到的主键 在'主索引B+树'中再执行一次B+树检索操作，
            最终到达叶子节点即可获取整行数据。(重点在于通过其他键需要建立次索引)

        为什么非聚簇索引的叶子节点要放聚簇索引的id？
            因为数据占的空间大，本来一个聚簇索引就占了不少空间 现在又要再创建个跟聚簇索引一样大的次索引，肯定是不行的


    主键索引(primary key)
        简称主键。它可以提高查询效率, 并提供唯一性约束。 一张表中只能有一个主键。被标志为自动增长的字段一定是主键(非主键字段不可自增),
        但主键不一定自动增长。一般把主键定义在无意义的字段上(如: 编号), 主键的数据类型最好是数值。

    全文索引(fulltext)
        做全文检索使用的索引, 我们有更好的替代品ElasticSearch,所以实际使用不多,只当了解。

        通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询, 但是 如果希望通过关键字的匹配来进行查询过滤,
        那么就需要基于相似度的查询, 不是原来的精确数值比较。全文索引就是为这种场景设计的。

        为什么不用like + %实现模糊匹配, 要全文索引?
        like + %在文本比较少时是合适的, 但是对于大量的文本数据检索是不可想象的。
        全文索引在大量的数据面前能比like + %快N倍, 速度不是一个数量级, 但是全文索引可能存在精度问题。

        你可能没有注意过全文索引, 不过至少应该对一种全文索引技术比较熟悉:各种的搜索引擎。虽然搜索引擎的索引对象是超大的数据,
        并且通常其背后都不是关系型数据库, 不过全文索引的基本原理是一样的。

        创建全文索引
            create fulltext index 索引名称 on 表名(字段名)
            alter table 表名 add fulltext(字段名)

    空间索引(spatial)
        这是在地理位置领域使用的一种索引

    hash索引
        hash索引速度快 可以快速定位到目标 时间复杂度为o(1), 但是hash是无序的。
        由于是无序的 所以有相同特征的key计算出来可能相隔很远 连续查询效率底下, 即不支持范围查询
        hash索引存储的是计算得到的hash值和行指针, 而不存储具体的行值, 所以通过hash索引查询数据需要进行两次查询(首先查询行的位置,然后找到具体的数据)
        hash索引查询数据的前提就是计算hash值, 也就是要求key为一个能准确指向一条数据的key, 所以对于like等一类的匹配查询是不支持的。
        所以我们可以知道的是hash索引适用于快速选取某一行的数据, 超级大表中定位某一行特别快。
        只要是只需要做等值比较查询, 而不包含排序或范围查询的需求, 都适合使用哈希索引。


    普通索引/常规索引(normal)
        创建普通索引
            创建表时添加: index 索引名称 (字段名称)
            创建完表添加: create index 索引名称 on 表名称(字段名称)

        创建短索引(短索引可以减少索引的体积 减少检索的时间提升查询的效率)
            创建完表添加: create index 索引名称 on 表名称(字段名称(length))

        删除索引
            drop index 索引名称 on 表名称

    唯一索引(unique)
        主键是一种约束, 唯一索引是一种索引, 两者在本质上是不同的。
        主键创建后一定包含一个唯一性索引, 唯一性索引并不一定就是主键。
        主键列不允许为空值, 而唯一性索引列允许空值。
        主键列在创建时, 已经默认为非空值+唯一索引了。
        主键可以被其他表引用为外键, 而唯一索引不能。
        一个表最多只能创建一个主键, 可以创建多个唯一索引。
        主键更适合那些不容易更改的唯一标识, 如自动递增列、身份证号等。
        唯一索引列不能有重复的值, 唯一索引不一定非要有唯一约束

        创建唯一索引
            create unique index 索引名称 on 表名称(字段名)

    复合索引
        索引的组合使用(索引合并) 效率是低于复合索引的。当有多个查询条件时,推荐使用复合索引。
        比如:我们经常按照A列B列C列进行查询时, 通常的做法是建立一个由三个列共同组成的复合索引而不是对每一个列建立普通索引。

        创建索引
            create index 索引名称 on 表名(字段名1,字段名2)

        注意事项
            1.最左前缀匹配原则, mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配, 后面的索引将全部失效。
                比如a=1 and b=2 and c>3 and d=4, 如果建立(a,b,c,d)顺序的索引 c是范围查询 d的索引就失效了,
                如果建立(a,b,d,c)的索引则都可以用到, a,b,d的顺序可以任意调整。
            2.=和in可以乱序，比如a=1 and b=2 and c=3建立(a,b,c)索引可以任意顺序, mysql的查询优化器会帮你优化成索引可以识别的形式。
            3.等值的字段放前面, 范围查询的字段一定要放到最后

            最左前缀匹配原则:
                左边的条件一定要是定值 不可以是范围, 比如A列索引是2,  3,3,3,  12,12,12,12  B列对应的数据是99,  3,4,2,  2,3,1,4。
                此时进行排序时B列数据就可以依赖A列数据进行排序为: 99,  2,3,4,  1,2,3,4。A在等值的情况下, 依赖A列的B列数据是有序的。
                如果条件是范围查询 A>3 and A<99, B列就不知道具体的值了 也就无法根据A的值进行排序了


-------------------------------------------------------------------------------------------------------------------------------------------------------

explain
    explain关键字可以模拟mysql优化器执行sql语句 可以很好的分析sql语句或表结构的性能瓶颈
    用途: 表的读取顺序如何 数据读取操作有哪些操作类型 哪些索引可以使用 哪些索引被实际使用 表之间是如何引用 每张表有多少行被优化器查询
    用法: explain 要分析的sql语句

    id       select查询的序列号, 表示查询中执行select子句或操作表的顺序
    select_type     查询的类型(是简单查询还是子查询等)
    table       正在访问哪个表
    partitions  匹配的分区
  * type        访问的类型
        Null > system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
        const: 表示通过索引一次就找到了(唯一索引定值查)
        ref: 非唯一性索引扫描, 返回匹配某个单独值的所有行(普通索引定值查)
        range: 只检索给定范围的行(索引范围查 索引在key中显示)
        index: 索引全扫描 只扫描索引树(如果搜索的数据大于总数据的50% 就会全表扫)
        all: 全表扫 差率最差

    possible_keys   显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到
  * key         实际使用到的索引，如果为NULL，则没有使用索引
    key_len     表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度
    ref         显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值
  * rows        根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数
    filtered    查询的表行占表的百分比
    Extra       包含不适合在其它列中显示但十分重要的额外信息


-------------------------------------------------------------------------------------------------------------------------------------------------------

事务
    在mysql中只有使用了innodb数据库引擎的数据库或表才支持事务
    事务处理可以用来维护数据库的完整性 保证成批的sql语句要么全部执行 要么全部不执行
    事务用来管理insert update delete语句

    事务的四大特性:
        原子性(Atomicity):
            一个事务 要么全部完成 要么全部失败, 不会结束在中间的某个环节。如果执行中发生错误 会回滚(Rollback)到事务开始前的状态

        一致性(Consistency):
            在事务开始之前和事务结束以后, 数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则,
            这包含资料的精确度串联性以及后续数据库可以自发性地完成预定的工作。(比如: A向B转账，不可能A扣了钱，B却没有收到)

        隔离性(Isolation):
            数据库允许多个并发事务同时对其数据进行读写和修改的能力, 隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
            事务隔离分为不同级别, 包括读未提交(Read uncommitted)、读提交(read committed)、可重复读(repeatable read)和串行化(Serializable)。
            (比如: A正在从一张银行卡里面取钱, 在A取钱的过程中, B不能向这张银行卡打钱)

        持久性(Durability):
            事务处理完毕后 对数据的修改是永久性的, 即使系统故障也不会丢失

        begin 开启事务、 commit 提交事务、 rollback 回滚事务

        设置隔离级别
            set session transaction isolation level repeatable read;   设置 会话 事务 隔离 级别 为可重复读

        事务的隔离性级别
            查看隔离级别:  show variables like '%iso%'

            读未提交: read uncommitted
                在该隔离级别, 所有事务都可以看到其他未提交事务的执行结果
                会出现的问题: 脏读  不可重复读  幻读
                脏读(Dirty Read): 对于两个事务T1与T2, T1读取了已经被T2更新但是还没有提交的字段之后, 若此时T2回滚, T1读取的内容就是临时并且无效的

            读已提交: read committed (针对delete update)
                事务只能看到别的事务已提交的数据
                会出现的问题: 不可重复读  幻读
                不可重复读(NonRepeatable Read): 同一事务的其他实例在该实例处理期间可能会有新的commit, 所以同一select可能返回不同结果。

            可重复读: repeatable read (针对delete insert)
                确保同一事务的多个实例在并发读取数据时, 其值都和事务开始时候的内容是一致, 禁止读取到别的事务未提交的数据
                会出现的问题: 幻读
                幻读(Phantom Read): 幻读指当用户读取某一范围的数据行时, 另一个事务又在该范围内插入了新行, 导致结果不一致的情况发生(mysql的MVCC已解决此问题)

            串行化: serializable
                这是最高的隔离级别, 它通过强制事务排序, 使之不可能相互冲突, 从而解决幻读问题。
                简言之, 它是在每个读的数据行上加上共享锁。在这个级别, 可能导致大量的超时现象和锁竞争。
                会出现的问题: 无

