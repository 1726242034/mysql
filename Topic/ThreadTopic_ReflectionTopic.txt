怎么解决线程安全问题
    不要一上来就使用Synchronized，这样会让程序的执行效率降低 在不得已的情况下再使用Synchronized
    尽量使用局部变量来代替实例变量(全局变量)和静态变量(局部变量在栈内存中 不共享数据 没有线程安全问题)
    如果必须使用全局变量 那么应该考虑创建多个对象 这样全局变量的内存就不共享了(一个线程对应一个对象 一百个线程对应一百个对象 对象不共享就没有线程安全问题)

线程的五种状态
    新建状态：刚new出来的线程状态
        start() 方法进入就绪状态
    就绪状态：就绪状态又叫可运行状态，表示当前线程具有抢夺CPU时间片的权力。当一个线程抢夺到CPU时间片就会执行 run() 方法，run() 方法的开始执行标示着线程进入运行状态
        JVM开始调度(yield)，分配线程开始执行
    运行状态：run()方法中的编写的代码开始执行，当当前占有的CPU时间片用完之后会重新回到就绪状态继续抢夺CPU时间片，当再次抢夺到CPU时间片之后会重新进入run()方法接着上一次的代码继续往下执行
        当遭遇到堵塞事件后 进入到堵塞状态
    堵塞状态：当一个线程遇到堵塞事件(接收用户键盘输入、sleep()等)后会进入到堵塞状态并放弃之前占有的CPU时间片
        堵塞状态解除，会再次回到就绪状态抢夺CPU时间片
    死亡状态：run()执行结束 线程死亡

线程有哪些状态？
    NEW 尚未启动
    RUNNABLE 正在执行中
    BLOCKED 阻塞的（被同步锁或者IO锁阻塞）
    WAITING 永久等待状态
    TIMED_WAITING 等待指定的时间重新被唤醒的状态
    TERMINATED 执行完成

在 Java 程序中怎么保证多线程的运行安全？
    方法一：使用安全类，比如 Java. util. concurrent 下的类。
    方法二：使用自动锁 synchronized。
    方法三：使用手动锁 Lock。
        Lock lock = new ReentrantLock();
        try {
            lock. lock();       获取锁
        } catch (Exception e) {
        } finally {
            lock. unlock();     释放锁
        }

多线程中 synchronized 锁升级的原理是什么？
    在锁对象的对象头里面有一个threadid字段，在第一次访问的时候threadid为空，jvm 让其持有偏向锁，并将threadid设置为其线程id，
    再次进入的时候会先判断threadid是否与其线程id一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，
    执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了synchronized锁的升级。

锁的升级的目的：
    锁升级是为了减低了锁带来的性能消耗。在Java 6之后优化synchronized的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。

怎么防止死锁？
    尽量使用tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。
    尽量使用Java. util. concurrent并发类代替自己手写锁。
    尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。
    尽量减少同步的代码块。

synchronized底层实现原理？
    synchronized是由一对' monitorenter/monitorexit '指令实现的，monitor对象是同步的基本实现单元。在Java 6之前，monitor的实现完全是依靠操作系统内部的互斥锁，
    因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在Java 6的时候，Java虚拟机对此进行了大刀阔斧地改进，
    提供了三种不同的monitor实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。

synchronized 和 volatile 的区别是什么？
    volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。
    volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。
    volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞

synchronized 和 Lock 有什么区别？
    synchronized 可以给类、方法、代码块加锁；而lock只能给代码块加锁。
    synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而lock需要自己加锁和释放锁，如果使用不当没有unLock()去释放锁就会造成死锁。
    通过Lock可以知道有没有成功获取锁，而 synchronized 却无法办到

说一下 atomic 的原理？
    atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升


================================================================================================================================================================================
                                            反射

什么是反射？
    反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；
    对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制

什么是 Java 序列化？什么情况下需要序列化？
    Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。
    以下情况需要使用Java序列化：
        想把的内存中的对象状态保存到一个文件中或者数据库中时候；
        想用套接字在网络上传送对象的时候；
        想通过RMI（远程方法调用）传输对象的时候。

对象拷贝
    为什么要使用克隆？
        克隆的对象可能包含一些已经修改过的属性，而new出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。

    如何实现对象克隆？
        实现 Cloneable 接口并重写 Object 类中的 clone() 方法。
        实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。

    深拷贝和浅拷贝区别是什么？
        浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。
        深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。

