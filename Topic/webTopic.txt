session 和 cookie 有什么区别？
    存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。
    安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。
    容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。
    存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。

session的工作原理
    客户端登录完成之后，服务器会创建对应的session，session创建完之后，会把session的id发送给客户端，客户端再存储到浏览器中。
    这样客户端每次访问服务器时，都会带着sessionId，服务器拿到sessionId之后，在内存找到与之对应的session这样就可以正常工作了。

如果客户端禁止cookie能实现session还能用吗？
    可以用，session只是依赖cookie存储sessionId，如果cookie被禁用了，可以使用url中添加sessionId的方式保证session能正常使用。

如何避免 SQL 注入？
    使用预处理 PreparedStatement。
    使用正则表达式过滤掉字符中的特殊字符。

什么是 XSS 攻击，如何避免？
    XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），
    当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。
    预防 XSS 的核心是必须对输入的数据做过滤处理。

什么是 CSRF 攻击，如何避免？
    CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，
    比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。
    防御手段：验证请求来源地址；关键操作添加验证码；在请求地址添加 token 并验证。

final、finally、finalize 有什么区别？
    final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。
    finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。
    finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。

try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
    finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。
    如果try和catch的return是一个变量时且函数的是从其中一个返回时，后面finally中语句即使有对返回的变量进行赋值的操作时，也不会影响try和catch返回的值。



                                    网络

http 响应码 301 和 302 代表的是什么？有什么区别？
    301：永久重定向。
    302：暂时重定向。
    它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。

forward 和 redirect 的区别？
    forward 是转发 和 redirect 是重定向：
    地址栏 url 显示：forward url 不会发生改变，redirect url 会发生改变；
    数据共享：forward 可以共享 request 里的数据，redirect 不能共享；
    效率：forward 比 redirect 效率高。

简述 tcp 和 udp的区别？
    tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。
    两者的区别大致如下：
        tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；
        tcp 提供可靠的服务（数据传输），udp 无法保证；
        tcp 面向字节流，udp 面向报文；
        tcp 数据传输慢，udp 数据传输快；


TCP三次握手：
    第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；
    第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
    第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED(建立了)状态，完成三次握手。
    握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下 TCP连接一旦建立 在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。

TCP四次挥手
    与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。
    第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了
        (当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。
    第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
    第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

TCP为什么要三次握手，两次不行吗？为什么？
    如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，
    这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。

说一下 tcp 粘包是怎么产生的？
    tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：
        发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；
        接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。

OSI 的七层模型都有哪些？
    物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。
    数据链路层：负责建立和管理节点间的链路。
    网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。
    传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。
    会话层：向两个实体的表示层提供建立和使用连接的方法。
    表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。
    应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。

get 和 post 请求有哪些区别？
    get 请求会被浏览器主动缓存，而 post 不会。
    get 传递参数有大小限制，而 post 没有。
    post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。

如何实现跨域？
    实现跨域有以下几种方案：
        服务器端运行跨域 设置 CORS 等于 *；
        在单个接口使用注解 @CrossOrigin 运行跨域；
        使用 jsonp 跨域；

87. 说一下 JSONP 实现原理？
    jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。




















