Mysql锁机制

    锁是为了保证数据的一致性。行锁必须建立在索引上, 如果没有索引那么就只会创建出表锁, 因为没有索引的话,
    mysql会全表扫描, 那样会锁定整张表所有的记录, 包括不存在的记录, 此时其他事务不能修改不能删除不能添加

    innodb支持表锁和行锁, myisam只支持表锁
        表锁: 当修改表中数据时 通过锁住整张表来保证数据一致性。特点是开销小 加锁快 不会出现死锁, 锁粒度大 发生锁冲突的概率小 并发度相对低
        行锁: 当修改表中数据时 通过锁住当前行来保证数据一致性。特点是开销大 加锁慢 会出现死锁, 锁粒度小 发生锁冲突的概率大 并发度相对高
    但并不是说行锁就一定比表锁快, 例如一张表有300w条数据 要修改150w数据才可以让其他程序执行, 此时就需要创建一次表锁 因为创建行锁就需要150w次

    锁类型
        记录锁(Record Lock):
            当前记录的锁 就是行锁(insert update操作自动加行锁), 行锁必须建立在索引上, 如果没有索引那么就只会创建出表锁
            因为没有索引的话, mysql会全表扫描, 那样会锁定整张表所有的记录, 包括不存在的记录, 此时其他事务不能修改不能删除不能添加
            不加索引 两个事务修改同一行记录  卡住了 创建的是表锁
            不加索引 两个事务修改同一表非同行记录  卡住了 创建的是表锁
            加索引 两个事务修改同一行记录 卡住了  创建的是行锁
            加索引 两个事务修改同表的不同行 可以修改  创建的是行锁


        间隙锁(GAP Lock):
            在RR(repeatable read)的隔离级别下 为了避免'幻读'引入了GAP Lock, 它锁定的是记录范围 不包含记录本身, 也就是不允许在范围内插入数据
            根据检索条件向下寻找最靠近检索条件的记录值A作为左区间 向上寻找最靠近检索条件的记录值B作为右区间 即锁定的间隙为A,B
            即: 如果where是xx = 10, 那么就会去找xx = 10的记录前一条A和后一条B, A和B之间的区间就会被锁住不允许添加数据
            即: 如果where是xx > 10, 那么10这个记录的'前一条记录往后'的所有记录都会被锁住不允许添加数据

                        id    num
                        1      2
                        3      4
                        6      5
                        8      5
                        10     5
                        13     11
            如果num=4, 那么间隙就是(1 2) - (6 5), (6 5)记录后面都不算。比如(5 5)就会被锁, 而(7 5)和(7 5)以后的就可以成功
            如果num=5 num的值有多个, 那么间隙就是(3 4) - (13 11)
            如果num=5, num的间隙就是4 - 11, 插入4 - 11都会堵塞, 4以前和11以后可以成功
            更新数据 num=5 where id=1  堵塞 (num=5在间隙中)
            插入数据 id=2 where num=4  成功 (num=4在区间中 但是id=2却在左区间3 4的前面 所以不受影响)
            插入数据 id=4 where num=4  堵塞 (num=4在区间中 而且id=4也在左区间3 4的后面 所以会堵塞)

            创建间隙锁(lock in share mode)
                select * from xx where xx = 9 lock in share mode


        临键锁(next-key lock):
            临键锁是' 记录锁和间隙锁的组合 ', 它的封锁范围既包含索引记录 也包含索引区间
            读取记录时 会先上一个Record Lock, 然后判断是否是唯一索引 不是的话就再上一个间隙锁

            注: 临键锁的主要目的也是为了避免幻读。如果把事务的隔离级别降级为RC(read committed) 临键锁也会失效

        表锁
            在InnoDB下 ，使用表锁要注意以下两点。
            1. 使用LOCK TALBES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层ＭySQL Server负责的，
               仅当autocommit=0、innodb_table_lock=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，ＭySQL Server才能感知InnoDB加的行锁，这种情况下，
               InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。

            2. 在用LOCAK TABLES对InnoDB锁时要注意，要将AUTOCOMMIT设为0，否则ＭySQL不会给表加锁；事务结束前，不要用UNLOCAK TABLES释放表锁，
               因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK不能释放用LOCAK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁，正确的方式见如下语句。

            加锁
                lock tables teacher write,student read;  给teacher表加一个写锁 给student表加一个读锁
                select * from teacher;
                commit;             建议提交事务后再释放锁
                unlock tables;      释放表锁

        读锁/共享锁:
            多个session可以同时读取表 但不能进行更改操作(读锁、写锁建立在索引上就是行锁, 建立在非主键字段就是表锁)
            加锁(使用lock in share mode): select * from test where sss = 10 lock in share mode;


        写锁/排他锁/独占锁/互斥锁:
            只有当前session可以往表中写数据 其他session不能进行读操作和写操作(mysql中使用了mvcc 使得其他session中可以读数据)
            加锁(使用for update): select * from test where sss = 10 for update;

        MDL锁
            MySQL 5.5引入了meta data lock，简称MDL锁，用于保证表中元数据的信息。在会话A中，表开启了查询事务后，会自动获得一个MDL锁，
            会话B就不可以执行任何DDL语句，不能执行为表中添加字段的操作，会用MDL锁来保证数据之间的一致性。元数据就是描述数据的数据，也就是你的表结构
            意思是在你开启了事务之后获得了意向锁，其他事务就不能修改你的表结构

        意向锁
            在mysql的innodb引擎中，意向锁是表级锁，意向锁有两种
            意向共享锁（IS） 是指在给一个数据行加共享锁前必须获取该表的意向共享锁
            意向排它锁（IX） 是指在给一个数据行加排他锁前必须获取该表的意向排他锁
            意向锁和MDL锁都是为了防止在事务进行中，执行DDL语句导致数据不一致。


    乐观锁(不加锁)
        乐观锁大多是基于数据版本记录机制实现，一般是给数据库表增加一个"version"字段。读取数据时，将此版本号一同读出，之后更新时，对此版本号加一。
        此时将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

        比如下单操作：
            查询出商品信息
                select number, version from teacher where id = 1;

            根据商品信息生成订单。
            将商品数量减1。
                update teacher set number = number-1，version = version + 1 where id = 1 and version = 3(查出来的version)


    悲观锁(都加锁)
        悲观锁依靠数据库提供的锁机制实现。MySQL中的共享锁和排它锁都是悲观锁。数据库的增删改操作默认都会加排他锁，而查询不会加任何锁。


锁等待
    锁等待是指一个事务过程中产生的锁，其他事务需要等待上一个事务释放它的锁，才能占用该资源。如果该事务一直不释放，
    就需要持续等待下去，直到超过了锁等待时间，会报一个等待超时的错误

    查看锁等待时间: select @@innodb_lock_wait_timeout
    修改锁等待时间: set innodb_lock_wait_timeout = 10

死锁
    死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，就是所谓的锁资源请求产生了回路现象，即死循环。
    InnoDB引擎可以自动检测死锁并回滚该事务 但是好不容易执行了一个业务给我回滚了，所以死锁尽量不要出现。
    死锁的条件
        1. 两行记录，至少两个事务
        2. 事务A 操作 第n行数据，并加锁 update teacher set name = 'a' where id = 1;
        3. 事务B 操作 第m行数据，并加锁 update teacher set name = 'b' where id = 2;
        4. 事务A 操作 第m行数据 update teacher set name = 'c' where id = 2;
        5. 事务B 操作 第n行数据 update teacher set name = 'd' where id = 1;
        6. 形成死锁 Deadlock found when trying to get lock; try restarting transaction

    如何避免死锁
        如果不同的程序会并发处理同一个表，或者涉及多行记录，尽量约定使用相同顺序访问表，可以大大减少死锁的发生。
        业务中尽量采用小事务，避免使用大事务，要及时提交和回滚事务，可减少死锁产生的概率。
        同一个事务中尽量做到一次锁定所需要的所有资源，减少死锁发生的概率。
        对于非常容易发生死锁的业务，可以尝试使用升级锁的力度，该用表锁减少死锁的发生


MVCC(Multi-Version Concurrency Control)多版本并发控制
    MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念(实现方式是快照读)
    MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。
    MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非堵塞并发读

    MVCC就是为了实现读--写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现
        当前读
            像select lock in share mode( 共享锁), select for update ; update, insert ,delete( 排他锁)这些操作都是一种当前读，
            为什么叫当前读？因为它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁

        快照读
            像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，
            串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，
            即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；
            既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

    MVCC带来的好处是？
        多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，
        版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。所以MVCC可以为数据库解决以下问题
        在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
        同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题

MVCC实现原理
    MVCC模型在MySQL中的具体实现则是由 3个隐式字段， undo日志 ， Read View 等去完成的，具体可以看下面的MVCC实现原理

    3个隐式字段
        每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID(隐式主键), DB_ROLL_PTR(事务ID) , DB_ROW_ID(回滚指针) 等字段
            DB_TRX_ID: 6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID
            DB_ROLL_PTR: 7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）
            DB_ROW_ID: 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引
            实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了

        比如一个表
            name    age    DB_TRX_ID    DB_ROLL_PTR    DB_ROW_ID
            jerry   24        1             1          0x11111111

            DB_ROW_ID 是数据库默认为该行记录生成的唯一隐式主键，
            DB_TRX_ID 是当前操作该记录的事务ID,
            DB_ROLL_PTR 是一个回滚指针，用于配合undo日志，指向上一个旧版本

    undo log
        事务中的修改操作 其实都是在表中真实的修改了，只是原来的旧数据被保存在了undo日志中，如果发生回滚操作 就会恢复undo日志中的旧数据
        写锁为什么可以让其他事务进行读操作? 因为其他事务读取的是undo日志中的旧数据

        undo log主要分为两种：
            insert undo log
                代表事务在insert 新记录时产生的undo log , 只在事务回滚时需要，并且在事务提交后可以被立即丢弃

            update undo log
                事务在进行update 或delete 时产生的undo log ; 不仅在事务回滚时需要，在快照读时也需要；
                所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge 线程统一清除

    purge线程，想成是一个环卫工人
        从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。
        为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，
        purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;
        如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的


    MVCC的执行流程
        在事务1修改数据时 数据库会先对该行加排他锁(写锁)，然后会把该行数据拷贝到undo log日志文件中作为旧数据，
        拷贝完成后修改该行数据，并且把隐式字段的事务ID修改为当前事务的ID 回滚指针指向undo log文件中的旧数据。
        不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记
        事务提交后释放锁

            事务2
                name    age    DB_TRX_ID    DB_ROLL_PTR    DB_ROW_ID
                tom     30        1             2          0x21111112指向旧数据

            undo log日志
                name    age    DB_TRX_ID    DB_ROLL_PTR    DB_ROW_ID
                tom     30        1             1          0x11111111指向上一个旧数据

                name    age    DB_TRX_ID    DB_ROLL_PTR    DB_ROW_ID
                jerry   24        1             null          null


Redo Log重做日志
    InnoDB的修改数据的基本流程: 当我们想要修改DB上某一行数据的时候，InnoDB是把数据从磁盘读取到内存的缓冲池上进行修改。
    数据在内存中被修改，与磁盘中相比就存在了差异，我们称这种有差异的数据为脏页。
    InnoDB对脏页的处理不是每次生成脏页就将脏页刷新回磁盘，这样会产生海量的IO操作，严重影响InnoDB的处理性能。
    对于此，InnoDB有一套完善的处理策略，与我们这次主题关系不大，表过不提。
    既然脏页与磁盘中的数据存在差异，那么如果在这期间DB出现故障就会造成数据的丢失。为了解决这个问题，redo log就应运而生了。

    mysql的日志有两种:
        Redo log在数据库重启的时候被使用 因为其属于物理日志的特性 恢复速度远快于逻辑日志。
        物理日志(存储了数据被修改的值)、
        逻辑日志(存储了逻辑sql修改语句)

    checkpoint(检查站)
        坦白来讲checkpoint本身是比较复杂的，checkpoint所做的事就是把脏页给刷新回磁盘。
        所以，当DB重启恢复时，只需要恢复checkpoint之后的数据。这样就能大大缩短恢复时间。当然checkpoint还有其他的作用。

    LSN(Log Sequence Number)
        LSN实际上就是InnoDB使用的一个版本标记的计数，它是一个单调递增的值。数据页和redo log都有各自的LSN。
        我们可以根据数据页中的LSN值和redo log中LSN的值判断需要恢复的redo log的位置和大小

    工作原理
        redo log就是存储了数据被修改后的值。当我们提交一个事务时，InnoDB会先去把要修改的数据写入日志，然后再去修改缓冲池里面的真正数据页。
        redo log本身也由两部分所构成即' 重做日志缓冲(redo log buffer) '和' 重做日志文件(redo log file) '。这样的设计同样也是为了调和内存与磁盘的速度差异。

        innodb_flush_log_at_trx_commit: InnoDB写入磁盘的策略是通过这个参数来控制
            为0时 表示事务提交不写入磁盘，写入过程在master thread中进行(会丢失掉master thread还没刷新进磁盘的部分数据)
            为1时 表示事务提交必须调用一次fsync函数(fsync函数的作用是把'重做日志缓冲'中的数据写入到'重做日志文件')
            为2时 表示事务提交时不写入重做日志文件，而是写入文件系统缓冲中

        master thread:
            这是InnoDB一个在后台运行的主线程，从名字就能看出这个线程相当的重要。它做的主要工作包括但不限于：刷新日志缓冲，合并插入缓冲，刷新脏页等。
            master thread大致分为每秒运行一次的操作和每10秒运行一次的操作。master thread中刷新数据，属于checkpoint的一种。
            所以如果在master thread在刷新日志的间隙，DB出现故障那么将丢失掉这部分数据。
            当该值为2时，当DB发生故障能恢复数据。但如果操作系统也出现宕机，那么就会丢失掉，文件系统没有及时写入磁盘的数据。
            当该值为0时，并不是说不会在master thread中刷新日志了。master thread刷新日志是在不断进行的，所以redo log写入磁盘是在持续的写入

    宕机恢复
        DB宕机后重启，InnoDB会首先去查看数据页中的LSN的数值。这个值代表数据页被刷新回磁盘的LSN的大小。然后再去查看redo log的LSN的大小。
        如果数据页中的LSN值大说明数据页领先于redo log刷新回磁盘，不需要进行恢复。反之需要从redo log中恢复数据。


存储引擎
    1、InnoDB存储引擎
        从MySQL5.5版本之后，MySQL的默认内置存储引擎已经是InnoDB了，他的主要特点有：
            支持事务。默认的事务隔离级别为可重复读，通过MVCC（并发版本控制）来实现的。
            使用的锁粒度为行级锁，可以支持更高的并发；
            支持外键；
            在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；
            对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+数的叶子节点上；

    2、MyISAM存储引擎
        在5.5版本之前，MyISAM是MySQL的默认存储引擎，该存储引擎并发性差，不支持事务，所以使用场景比较少，主要特点为：
            不支持事务；
            不支持外键，如果强行增加外键，不会提示错误，只是外键不其作用；
            对数据的查询缓存只会缓存索引，不会像InnoDB一样缓存数据，而且是利用操作系统本身的缓存；
            默认的锁粒度为表级锁，所以并发度很差，加锁快，锁冲突较少，所以不太容易发生死锁；
            支持全文索引（MySQL5.6之后，InnoDB存储引擎也对全文索引做了支持），
                但是MySQL的全文索引基本不会使用，对于全文索引，现在有其他成熟的解决方案，比如：ElasticSearch，Solr，Sphinx等。
            数据库所在主机如果宕机，MyISAM的数据文件容易损坏，而且难恢复；

    两种引擎的对比
        1、由于锁粒度的不同，InnoDB比MyISAM支持更高的并发；
        2、InnoDB为行级锁，MyISAM为表级锁，所以InnoDB相对于MyISAM来说，更容易发生死锁，锁冲突的概率更大，而且上锁的开销也更大，因为需要为每一行加锁；
        3、在备份容灾上，InnoDB支持在线热备，有很成熟的在线热备解决方案；
        4、查询性能上，MyISAM的查询效率高于InnoDB，因为InnoDB在查询过程中，是需要维护数据缓存，而且查询过程是先定位到行所在的数据块，
            然后在从数据块中定位到要查找的行；而MyISAM可以直接定位到数据所在的内存地址，可以直接找到数据；
        5、SELECT COUNT(*)语句，如果行数在千万级别以上，MyISAM可以快速查出，而InnoDB查询的特别慢，因为MyISAM将行数单独存储了，
            而InnoDB需要逐行去统计行数；所以如果使用InnoDB，而且需要查询行数，则需要对行数进行特殊处理，如：离线查询并缓存；
        6、MyISAM的表结构文件包括：.frm(表结构定义),.MYI(索引),.MYD(数据)；而InnoDB的表数据文件为:.ibd和.frm(表结构定义)；

    选择合适的存储引擎
        1、使用场景是否需要事务支持；
        2、是否需要支持高并发，InnoDB的并发度远高于MyISAM；
        3、是否需要支持外键；
        4、高效缓冲数据，InnoDB对数据和索引都做了缓冲，而MyISAM只缓冲了索引；
        5、索引，不同存储引擎的索引并不太一样；

怎么sql优化
    少用子查询 多用左连接
    使用索引
    合理的使用表锁和行锁
    少用大事务 多用小事务


